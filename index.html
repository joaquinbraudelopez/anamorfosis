<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador A4 Full (Cilindro al Borde)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; text-align: center; background: #333; color: #fff; margin: 0; padding: 20px; }
        
        .no-print { max-width: 600px; margin: 0 auto; background: white; color: #333; padding: 30px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        h1 { margin-bottom: 10px; color: #222; }
        
        .upload-btn-wrapper { margin-bottom: 20px; }
        .btn { border: 2px solid #555; background-color: #eee; padding: 8px 20px; border-radius: 8px; font-weight: bold; cursor: pointer; }
        
        input[type="range"] { width: 100%; margin: 10px 0; }
        
        button.print-btn { background: #28a745; color: white; border: none; padding: 15px 40px; font-size: 20px; border-radius: 50px; cursor: pointer; margin-top: 20px; font-weight: bold;}
        button.print-btn:hover { background: #218838; }

        /* PREVISUALIZACI√ìN EN PANTALLA */
        #canvas-container { 
            margin-top: 20px; 
            background: #555; 
            padding: 20px; 
            display: inline-block;
            border-radius: 10px;
        }
        canvas { 
            background: white; 
            max-width: 300px; /* Se ve peque√±o en pantalla pero es A4 real */
            height: auto; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* --- IMPRESI√ìN A4 EXACTA --- */
        @media print {
            @page { 
                size: A4 portrait; 
                margin: 0; 
            }
            body, html { 
                margin: 0; 
                padding: 0; 
                background: white; 
                width: 100%;
                height: 100%;
            }
            .no-print { display: none !important; } 
            
            #canvas-container { 
                background: none; 
                padding: 0; 
                margin: 0; 
                width: 100%; 
                height: 100%; 
                display: block; 
            }
            
            canvas {
                width: 210mm !important; 
                height: 297mm !important; 
                max-width: none;
                box-shadow: none;
                display: block;
            }
        }
    </style>
</head>
<body>

<div class="no-print">
    <h1>üöÄ Modo A4 Completo</h1>
    <p>La imagen usar√° toda la hoja. Coloca el cilindro en el semic√≠rculo inferior.</p>
    
    <div class="upload-btn-wrapper">
        <button class="btn">üìÇ 1. Subir Foto</button>
        <input type="file" id="upload" accept="image/*">
    </div>

    <div id="controls" style="display:none;">
        <label>üîç Zoom (Tama√±o)</label>
        <input type="range" id="scale" min="50" max="300" value="100">
        
        <label>‚¨ÜÔ∏è Altura (Alejar del cilindro)</label>
        <input type="range" id="offset" min="0" max="150" value="20">
        
        <br>
        <button class="print-btn" onclick="window.print()">üñ®Ô∏è IMPRIMIR</button>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scaleSlider = document.getElementById('scale');
    const offsetSlider = document.getElementById('offset');
    const controlsDiv = document.getElementById('controls');

    let img = new Image();
    let isImageLoaded = false;

    // --- GEOMETR√çA A4 REAL ---
    // A4 es 210mm x 297mm.
    // Cilindro es 60mm.
    // Relaci√≥n de pixeles para alta calidad (300 DPI aprox)
    // Ancho = 2480 px, Alto = 3508 px
    const CANVAS_WIDTH = 2480;
    const CANVAS_HEIGHT = 3508;
    
    // El radio del cilindro (30mm) en relaci√≥n al ancho de la hoja (210mm)
    // 30 / 210 = 0.1428... del ancho total
    const CYLINDER_RADIUS_PX = CANVAS_WIDTH * (30 / 210);

    upload.addEventListener('change', (e) => {
        if(e.target.files && e.target.files[0]){
            const reader = new FileReader();
            reader.onload = (event) => {
                img.onload = () => {
                    isImageLoaded = true;
                    controlsDiv.style.display = 'block';
                    draw();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        }
    });

    scaleSlider.addEventListener('input', draw);
    offsetSlider.addEventListener('input', draw);

    function draw() {
        if (!isImageLoaded) return;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        // EL CENTRO MATEM√ÅTICO EST√Å ABAJO AL MEDIO
        const cx = CANVAS_WIDTH / 2;
        const cy = CANVAS_HEIGHT; // Justo en el borde inferior de la hoja
        
        // El radio m√°ximo es la diagonal hasta la esquina superior
        const maxRadius = Math.sqrt(Math.pow(CANVAS_WIDTH/2, 2) + Math.pow(CANVAS_HEIGHT, 2));

        // Limpiar
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Buffer imagen
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(img, 0, 0);
        const sourceData = tempCtx.getImageData(0, 0, img.width, img.height);

        const destImageData = ctx.createImageData(CANVAS_WIDTH, CANVAS_HEIGHT);
        const data = destImageData.data;

        // C√°lculos
        // rInner es el borde f√≠sico del cilindro
        const rInner = CYLINDER_RADIUS_PX; 
        
        // Offset: empujar la imagen hacia arriba
        const offsetVal = offsetSlider.value * 10; // Multiplicador para dar m√°s rango
        const rStart = rInner + offsetVal;

        const zoom = scaleSlider.value / 100;
        
        // √Ångulo del abanico: Usamos un poco menos de 180 para que no se deforme tanto en los bordes extremos
        const SECTOR_ANGLE = Math.PI * 0.9; 

        for (let y = 0; y < CANVAS_HEIGHT; y++) {
            for (let x = 0; x < CANVAS_WIDTH; x++) {
                const dx = x - cx;
                const dy = y - cy; // dy ser√° negativo porque y < cy
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Si estamos dentro del cilindro o antes del inicio de la imagen, saltar
                if (dist < rStart) continue;

                // √Ångulo
                // Math.atan2(dy, dx). Como dy es negativo (arriba del borde inferior), el √°ngulo va de -PI a 0.
                // Queremos que el centro (x=cx) sea 0.
                // atan2(dy, dx) -> -PI/2 es arriba (centro).
                
                let angle = Math.atan2(dy, dx); 
                // Rotamos para que -PI/2 sea nuestro 0
                let adjustedAngle = angle + (Math.PI / 2);

                const halfSector = SECTOR_ANGLE / 2;
                if (Math.abs(adjustedAngle) > halfSector) continue;

                // Mapeo X (√Ångulo -> Ancho imagen)
                const anglePercent = (adjustedAngle + halfSector) / SECTOR_ANGLE;
                const u = anglePercent * img.width;
                
                // Mapeo Y (Distancia -> Alto imagen)
                // Aqu√≠ usamos una escala logar√≠tmica suave o lineal. Vamos lineal por ahora.
                // Mapeamos desde rStart hasta donde termine la hoja (aprox maxRadius)
                const distNormalizada = (dist - rStart) / (CANVAS_HEIGHT - rInner); // Normalizaci√≥n aprox
                
                // Invertimos: Cerca del cilindro = Abajo de la imagen (y=height)
                const v = (1 - distNormalizada) * img.height * zoom;

                if (v < 0 || v >= img.height) continue;

                const safeX = Math.min(Math.max(Math.floor(u), 0), img.width - 1);
                const safeY = Math.min(Math.max(Math.floor(v), 0), img.height - 1);

                const srcIndex = (safeY * img.width + safeX) * 4;
                const destIndex = (y * CANVAS_WIDTH + x) * 4;

                data[destIndex] = sourceData.data[srcIndex];
                data[destIndex + 1] = sourceData.data[srcIndex + 1];
                data[destIndex + 2] = sourceData.data[srcIndex + 2];
                data[destIndex + 3] = 255;
            }
        }

        ctx.putImageData(destImageData, 0, 0);
        
        // --- GU√çAS VISUALES ---
        
        // 1. D√≥nde va el cilindro (Semic√≠rculo gris abajo)
        ctx.beginPath();
        ctx.arc(cx, cy, rInner, Math.PI, 0); // Arco superior
        ctx.fillStyle = "#ddd";
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "#999";
        ctx.stroke();
        
        // Texto en el cilindro
        ctx.fillStyle = "#666";
        ctx.font = "bold 60px Arial";
        ctx.textAlign = "center";
        ctx.fillText("CILINDRO", cx, cy - 80);
        ctx.font = "40px Arial";
        ctx.fillText("AQU√ç", cx, cy - 30);

        // 2. Muesca / Flecha de alineaci√≥n (Invertida, apuntando al cilindro)
        // La dibujamos sobre el borde del cilindro
        ctx.beginPath();
        ctx.moveTo(cx, cy - rInner); // Punta tocando el borde del cilindro
        ctx.lineTo(cx - 50, cy - rInner - 80);
        ctx.lineTo(cx + 50, cy - rInner - 80);
        ctx.closePath();
        ctx.fillStyle = "#333";
        ctx.fill();

        // 3. L√≠nea de inicio de imagen (si hay offset)
        if (offsetSlider.value > 0) {
            ctx.beginPath();
            ctx.arc(cx, cy, rStart, Math.PI, 0);
            ctx.strokeStyle = "#ffaaaa";
            ctx.setLineDash([20, 20]);
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
</script>

</body>
</html>
